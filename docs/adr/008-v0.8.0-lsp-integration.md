# ADR 008 - v0.8.0 LSP Integration Strategy

**Status**: Proposed

**Date**: 2025-01-17

**Authors**: Felix Geelhaar

## Context

cclint is currently a CLI-only tool. Developers must:

1. Save their file
2. Switch to terminal
3. Run `cclint lint CLAUDE.md`
4. Read output
5. Switch back to editor
6. Find the line with the issue
7. Fix and repeat

This workflow is significantly slower than modern linting tools that provide real-time feedback in the editor. The Language Server Protocol (LSP) is the industry standard for editor integration, supporting VS Code, Neovim, Emacs, Sublime Text, and many other editors.

### Requirements

- Real-time diagnostics as users type
- Quick fixes via CodeActions
- Hover documentation for rules
- Works with any LSP-compatible editor
- No editor-specific code in core

## Decision

Implement a full LSP server for cclint that integrates with the existing core linting engine.

### Architecture

```
┌──────────────────────────────────────────────────────────────────┐
│                        Editor Layer                               │
├────────────────┬────────────────┬────────────────┬───────────────┤
│    VS Code     │    Neovim      │     Emacs      │    Others     │
│   Extension    │  nvim-lspconfig│   lsp-mode     │     LSP       │
└───────┬────────┴───────┬────────┴───────┬────────┴───────┬───────┘
        │                │                │                │
        └────────────────┴────────────────┴────────────────┘
                                  │
                     ┌────────────▼────────────┐
                     │    cclint LSP Server    │
                     │  (vscode-languageserver)│
                     └────────────┬────────────┘
                                  │
                     ┌────────────▼────────────┐
                     │    Core Linting Engine  │
                     │      (existing)         │
                     └─────────────────────────┘
```

### LSP Capabilities

| Capability                        | Implementation                | Priority |
| --------------------------------- | ----------------------------- | -------- |
| `textDocument/publishDiagnostics` | Map violations to diagnostics | P0       |
| `textDocument/codeAction`         | Quick fixes from AutoFixer    | P0       |
| `textDocument/hover`              | Rule documentation            | P1       |
| `textDocument/completion`         | Section name completion       | P2       |
| `textDocument/formatting`         | Markdown formatting           | P2       |
| `workspace/configuration`         | Support .cclintrc.json        | P1       |

### Technology Choice: vscode-languageserver

Use the `vscode-languageserver` npm package:

**Pros**:

- Official Microsoft implementation
- Battle-tested in hundreds of language servers
- Full LSP specification support
- Great TypeScript types
- Works with ANY LSP client, not just VS Code

**Cons**:

- ~200KB bundle size addition
- Learning curve for LSP concepts

**Alternatives Considered**:

1. **Custom LSP from scratch**
   - Rejected: Reinventing the wheel, error-prone

2. **Tree-sitter based**
   - Rejected: Overkill for markdown, not necessary

3. **Prettier-style JSON protocol**
   - Rejected: Non-standard, requires custom clients

### VS Code Extension Strategy

Create a separate repository `cclint-vscode` that:

1. Bundles the LSP server
2. Adds VS Code-specific features:
   - Syntax highlighting for CLAUDE.md
   - Status bar quality score
   - Commands in command palette
   - Extension settings UI

This keeps the core LSP pure and reusable.

### Server Lifecycle

```typescript
// Connection modes
type ConnectionMode =
  | 'stdio'      // Standard input/output (most common)
  | 'pipe'       // Named pipes
  | 'socket'     // TCP socket (for debugging)
  | 'node-ipc';  // Node IPC (VS Code default)

// Server startup
cclint lsp                    # stdio mode (default)
cclint lsp --pipe=<name>      # Named pipe
cclint lsp --socket=<port>    # TCP socket
cclint lsp --node-ipc         # Node IPC
```

## File Structure

```
src/lsp/
├── server.ts              # Main LSP server entry
├── capabilities.ts        # LSP capability handlers
├── DiagnosticProvider.ts  # Violation → Diagnostic mapping
├── CodeActionProvider.ts  # Fix → CodeAction mapping
├── HoverProvider.ts       # Rule documentation on hover
├── CompletionProvider.ts  # Section name completion
├── ConfigurationManager.ts # Workspace config handling
└── DocumentManager.ts     # Open document tracking

packages/vscode-cclint/    # Separate VS Code extension
├── package.json
├── src/
│   └── extension.ts
└── syntaxes/
    └── claude-md.tmLanguage.json
```

## Implementation Details

### Diagnostic Mapping

```typescript
function violationToDiagnostic(v: Violation): Diagnostic {
  return {
    range: {
      start: { line: v.location.line - 1, character: v.location.column - 1 },
      end: {
        line: v.location.line - 1,
        character: v.location.column + v.location.length,
      },
    },
    severity: severityToLspSeverity(v.severity),
    code: v.ruleId,
    source: 'cclint',
    message: v.message,
    data: { ruleId: v.ruleId, fixable: v.fix !== null },
  };
}

function severityToLspSeverity(s: Severity): DiagnosticSeverity {
  switch (s) {
    case Severity.Error:
      return DiagnosticSeverity.Error;
    case Severity.Warning:
      return DiagnosticSeverity.Warning;
    case Severity.Info:
      return DiagnosticSeverity.Information;
  }
}
```

### CodeAction for Quick Fixes

```typescript
function createQuickFix(
  diagnostic: Diagnostic,
  fix: AutoFix,
  document: TextDocument
): CodeAction {
  return {
    title: `Fix: ${fix.description}`,
    kind: CodeActionKind.QuickFix,
    diagnostics: [diagnostic],
    isPreferred: true,
    edit: {
      changes: {
        [document.uri]: [
          {
            range: fix.range,
            newText: fix.replacement,
          },
        ],
      },
    },
  };
}
```

### Incremental Linting

To avoid performance issues, implement debounced linting:

```typescript
class DocumentManager {
  private lintDebounceMs = 200;
  private pendingLints = new Map<string, NodeJS.Timeout>();

  onDocumentChange(uri: string, content: string): void {
    // Cancel pending lint for this document
    const pending = this.pendingLints.get(uri);
    if (pending) clearTimeout(pending);

    // Schedule new lint
    this.pendingLints.set(
      uri,
      setTimeout(() => {
        this.lintDocument(uri, content);
        this.pendingLints.delete(uri);
      }, this.lintDebounceMs)
    );
  }
}
```

## Consequences

### Positive Consequences

- **Universal editor support**: One implementation works everywhere
- **Real-time feedback**: Issues shown as users type
- **Quick fixes in editor**: No context switching
- **Hover documentation**: Learn rules without leaving editor
- **Professional quality**: Same experience as TypeScript, ESLint, etc.

### Negative Consequences

- **Bundle size increase**: ~200KB for vscode-languageserver
- **Complexity**: LSP has a learning curve
- **Two packages to maintain**: Core + VS Code extension
- **Testing complexity**: Need to mock LSP protocol

### Neutral Consequences

- CLI remains the primary interface for CI/CD
- VS Code extension will be most popular, but not required
- Other editors need their own small config (nvim-lspconfig, etc.)

## Follow-up Actions

- [ ] Create `src/lsp/` directory structure
- [ ] Add vscode-languageserver dependency
- [ ] Implement DiagnosticProvider
- [ ] Implement CodeActionProvider
- [ ] Create separate vscode-cclint repository
- [ ] Write LSP integration tests
- [ ] Document editor setup for Neovim, Emacs

## References

- [Language Server Protocol Specification](https://microsoft.github.io/language-server-protocol/)
- [vscode-languageserver npm](https://www.npmjs.com/package/vscode-languageserver)
- [Building a Language Server](https://code.visualstudio.com/api/language-extensions/language-server-extension-guide)
- Related ADRs: [003-hexagonal-architecture](./003-hexagonal-architecture.md), [007-v0.7.0-developer-experience](./007-v0.7.0-developer-experience.md)
